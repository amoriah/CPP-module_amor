 						Общие правила
		Компиляция
- Скомпилируйте ваш код с помощью c++ и флагов -Wall -Wextra -Werror
- Ваш код должен компилироваться, если вы добавите флаг -std=c++98 Форматирование и соглашения об именовании
- Каталоги упражнений будут названы следующим образом: ex00, ex01, ... , exn
- Назовите свои файлы, классы, функции, функции-члены и атрибуты так, как это требуется в руководства.
- Пишите имена классов в формате UpperCamelCase. Файлы, содержащие код класса, будут всегда будут называться в соответствии с именем класса. Например:
ClassName.hpp/ClassName.h, ClassName.cpp или ClassName.tpp. Затем, если у вас есть заголовочный файл, содержащий определение класса "BrickWall", обозначающего
кирпичной стены, его имя будет BrickWall.hpp.
- Если не указано иное, каждое выходное сообщение должно заканчиваться символом новой строки и выводиться на стандартный вывод.
- Прощай нормативка! В модулях C++ нет принудительного стиля кодирования. Вы можете следовать своему любимому. Но имейте в виду, что код, который ваши коллеги оценщики не могут понять - это код, который они не смогут оценить. Сделайте все возможное, чтобы написать чистый и читабельный код.
		Разрешенное/запрещенное
Вы больше не пишете на C. Пора переходить на C++! Поэтому:
- Вам разрешено использовать почти все из стандартной библиотеки. Таким образом, вместо того, чтобы придерживаться того, что вы уже знаете, было бы разумно использовать как можно больше C++-шных версий функций Си, к которым вы привыкли.
- Однако вы не можете использовать никакие другие внешние библиотеки. Это означает, что библиотеки C++11 (и производные формы) и Boost запрещены. Также запрещены следующие функции: *printf(), *alloc() и free(). Если вы их используете, ваша оценка будет 0 и все.

- Обратите внимание, что если явно не указано иное, использование пространства имен <ns_name> и ключевые слова friend запрещены. В противном случае ваша оценка будет -42.
- Вам разрешено использовать STL только в модуле 08. Это означает: нет контейнеры (вектор/список/карта/и т.д.) и алгоритмы (все, что требует включения заголовка <algorithm>) до этого момента. В противном случае ваша оценка будет будет -42.
		Несколько требований к проектированию
- Утечка памяти происходит и в C++. Когда вы выделяете память (используя ключевое слово new ), вы должны избегать утечек памяти.
- С модуля 02 по модуль 08 ваши классы должны быть спроектированы в ортодоксальной Каноническая форма, за исключением случаев, когда явно указано иное.
- Любая реализация функции, помещенная в заголовочный файл (за исключением шаблонов функций) означает 0 в упражнении.
- Вы должны иметь возможность использовать каждый из ваших заголовков независимо от других. Таким образом, они должны включать все необходимые зависимости. Однако вы должны избегать проблемы двойного включения, добавляя защитные экраны включения. В противном случае ваша оценка будет будет 0.
		Читать
- Вы можете добавить несколько дополнительных файлов, если вам это необходимо (т.е. разделить ваш код). Поскольку эти задания не проверяются программой, не стесняйтесь делать это до тех пор, пока вы сдаете обязательные файлы.
- Иногда рекомендации к упражнению выглядят короткими, но примеры могут показать требования, которые не написаны в инструкциях в явном виде.
- Перед началом работы полностью прочитайте каждый модуль! Действительно, сделайте это.
- Клянусь Одином, клянусь Тором! Используйте свой мозг!!!
Вам придется реализовать множество классов. Это может показаться утомительным, если только вы не умеете писать сценарии в своем любимом текстовом редакторе.
Вам дается определенная свобода в выполнении упражнений.
Однако следуйте обязательным правилам и не ленитесь. Иначе вы пропустите много полезной информации! Не стесняйтесь читать о теоретические концепции.

		ex00
		
Сначала реализуйте класс Zombie. У него есть строковый приватный атрибут name.
Добавьте функцию-член void announce( void ); в класс Zombie. 

Зомби объявляют о себе следующим образом:
<имя>: BraiiiiiiiiiiinnnnzzzZ...

Не печатайте угловые скобки (< и >). Для зомби с именем Foo сообщение
будет следующим:
Foo: BraiiiiiiiiiiinnnnzzzZ...

Затем реализуйте две следующие функции:
- Zombie* newZombie( std::string name );
Она создает зомби, присваивает ему имя и возвращает его, чтобы вы могли использовать его вне области действия функции.

- void randomChump( std::string name );
Создает зомби, дает ему имя, и зомби объявляет о себе.

Итак, в чем, собственно, смысл упражнения? Вы должны определить, в каком случае
лучше выделять зомби на стеке или в куче.
Зомби должны быть уничтожены, когда они вам больше не нужны. Деструктор должен выводить сообщение с именем зомби для целей отладки.

			ex01
			
Пора создать орду зомби!
Реализуйте следующую функцию в соответствующем файле:
Zombie* zombieHorde( int N, std::string name );
Она должна выделить N объектов Зомби за одно распределение. Затем она должна инициализировать
зомби, присвоив каждому из них имя, переданное в качестве параметра. Функция возвращает
указатель на первого зомби.

Проведите собственные тесты, чтобы убедиться, что ваша функция zombieHorde() работает так, как ожидается.
Попробуйте вызвать функцию announce() для каждого из зомби.

Не забудьте удалить всех зомби и проверить на утечку памяти.

		ex02
		
Напишите программу, которая содержит:
- Строковую переменную, инициализированную в "HI THIS IS BRAIN".
- stringPTR: указатель на строку.
- stringREF: Ссылка на строку.

Ваша программа должна вывести:
- Адрес памяти строковой переменной.
- Адрес памяти, хранящийся в stringPTR.
- Адрес памяти, хранящийся в stringREF.

А затем:
- Значение строковой переменной.
- Значение, на которое указывает stringPTR.
- Значение, на которое указывает stringREF.

Вот и все, никаких хитростей. Целью этого упражнения является демистификация ссылок, которые могут
показаться совершенно новыми. Хотя есть некоторые небольшие различия, это другой синтаксис
для того, что вы уже делаете: работа с адресами.

		ex03
		
Реализуйте класс Weapon, который имеет:
- Частный атрибут type, который является строкой.
- Функция-член getType(), которая возвращает const-ссылку на тип.
- Функция-член setType(), которая устанавливает тип, используя новый, переданный в качестве параметра

Теперь создайте два класса: HumanA и HumanB. Они оба имеют оружие и
имя. У них также есть функция-член attack(), которая отображает (конечно, без
угловых скобок):
<имя> атакует своим <типом оружия>.
HumanA и HumanB почти одинаковы, за исключением этих двух крошечных деталей:
- В то время как HumanA принимает Оружие в своем конструкторе, HumanB не принимает.
- HumanB не всегда может иметь оружие, в то время как HumanA всегда будет вооружен.

Если ваша реализация верна, то выполнение следующего кода напечатает атаку
с "грубой дубиной с шипами", затем вторую атаку с "каким-то другим видом дубины" для обоих
тестовых случаев:
int main()
{
	{
		Weapon club = Weapon("грубая шипованная дубина");
		ЧеловекА bob("Боб", дубина);
		bob.attack();
		club.setType("какой-то другой тип дубины");
		bob.attack();
	}
	{
		Weapon club = Weapon("грубая дубина с шипами");
		HumanB jim("Джим");
		jim.setWeapon(club);
		jim.attack();
		club.setType("какой-то другой тип дубины");
		jim.attack();
	}	
return 0;
}
Не забудьте проверить утечку памяти.
Как вы думаете, в каком случае лучше использовать указатель на
Weapon? И ссылку на Weapon? Почему? Подумайте об этом, прежде чем
приступить к выполнению этого упражнения.

			ex05

Вы знаете Харла? Мы все знаем, не так ли? Если вы не знаете,
найдите ниже, какие комментарии Харла. Они классифицированы 
по уровням:
- Уровень "DEBUG": Отладочные сообщения содержат контекстную 
информацию. Они в основном используются для диагностики проблем.
Пример: "Мне нравится, когда к моему бургеру 7XL-double-cheese-
triple-pickle-specialketchup добавляют дополнительный бекон. Правда!"
- Уровень "INFO": Эти сообщения содержат обширную информацию. 
Они полезны для отслеживания выполнения программы в производственной среде.
Пример: "Не могу поверить, что добавление дополнительного бекона 
стоит больше денег. Вы не положили недостаточно бекона в мой бургер! 
Если бы вы положили, я бы не просил добавки!".
- Уровень "ПРЕДУПРЕЖДЕНИЕ": Предупреждающие сообщения указывают 
на потенциальную проблему в системе.
Однако ее можно решить или проигнорировать.
Пример: "Я думаю, что заслуживаю получить немного дополнительного 
бекона бесплатно. Я хожу сюда уже много лет, в то время как вы 
начали работать здесь с прошлого месяца".
- Уровень "ERROR": Эти сообщения указывают на то, что произошла 
неустранимая ошибка.
Обычно это критическая проблема, требующая ручного вмешательства.
Пример: "Это неприемлемо! Я хочу поговорить с менеджером прямо сейчас".

Вы собираетесь автоматизировать Harl. Это будет несложно, так как 
он всегда говорит одно и то же вещи. Вы должны создать класс Harl
 со следующими частными функциями-членами:
- void debug( void );
- void info( void );
- void warning( void );
- void error( void );
Harl также имеет публичную функцию-член, которая вызывает четыре 
функции-члена выше в зависимости от уровня, переданного в качестве параметра:
void complain( std::string level );
Цель этого упражнения - использовать указатели на функции-члены. Это не
предложение. Harl должен жаловаться без использования леса if/else if/else. 
Он не думает дважды!
Создайте и сдайте тесты, показывающие, что Harl часто жалуется. 
Вы можете использовать пример комментарии.



