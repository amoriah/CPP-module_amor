C++ - Module 06
C++ casts

Дополнительное правило
Следующее правило относится ко всему модулю и не является необязательным.
Для каждого упражнения приведение типа должно быть решено с использованием 
одного конкретного типа приведения.
Ваш выбор будет проверен во время защиты.

Упражнение 00: Преобразование скалярных типов

Напишите программу, которая принимает в качестве параметра 
строковое представление литерала C++ в наиболее распространенной форме. Этот литерал должен 
принадлежать к одному из следующих скалярных типов:
char, int, float или double. За исключением параметров char, 
будет использоваться только десятичная нотация. Примеры литералов char: 'c', 'a', ...
Чтобы упростить работу, обратите внимание, что не отображаемые 
символы не должны использоваться в качестве
ввода. 

Если преобразование в char не является отображаемым, 
выводится информационное сообщение.

Примеры литералов int: 0, -42, 42...
Примеры литералов float: 0.0f, -4.2f, 4.2f...
Вы также должны обрабатывать эти псевдобуквы 
(ну, вы знаете, для науки): -inff, +inff
и nanf.
Примеры двойных литералов: 0.0, -4.2, 4.2...
Вам также придется работать с этими псевдолитералами (ну, вы 
понимаете, для развлечения): -inf, +inf и nan.
Сначала нужно определить тип литерала, переданного в качестве 
параметра, преобразовать его из типа
string в его реальный тип, затем явно преобразовать его в три 
других типа данных. И наконец,
вывести результаты на экран, как показано ниже.
Если преобразование не имеет смысла или переполняется, выведите 
на экран сообщение о том, что
пользователя о том, что преобразование типа невозможно. Включите 
любой заголовок, необходимый для того, чтобы
обработки числовых ограничений и специальных значений.

./convert 0
char: Non displayable
int: 0
float: 0.0f
double: 0.0
./convert nan
char: impossible
int: impossible
float: nanf
double: nan
./convert 42.0f
char: '*'
int: 42
float: 42.0f
double: 42.0

Упражнение 01: Сериализация

Реализуйте следующие функции:
uintptr_t serialize(Data* ptr);
Принимает указатель и преобразует его в беззнаковый целочисленный тип uintptr_t.
Data* deserialize(uintptr_t raw);
Принимает беззнаковый целочисленный параметр и преобразует его в указатель на Data.
Напишите программу для проверки того, что ваши функции работают так, как ожидалось.
Вы должны создать непустую (это означает, что у нее есть члены данных) структуру Data.
Используйте функцию serialize() для адреса объекта Data и передайте ее
 возвращаемое значение в функцию
deserialize(). Затем убедитесь, что возвращаемое значение функции deserialize() равно
исходному указателю.
Не забудьте сдать файлы вашей структуры Data.


Упражнение 02: Определение реального типа

Реализуйте класс Base, который имеет только публичный виртуальный деструктор. Создайте три пустых
класса A, B и C, которые публично наследуются от Base.
Эти четыре класса не обязательно должны быть спроектированы в ортодоксальной
канонической форме.
Реализуйте следующие функции:
Base * generate(void);
Эта функция произвольно создает экземпляр A, B или C и возвращает его в виде указателя на Base. Не стесняйтесь
использовать для реализации случайного выбора все, что вам нравится.
void identify(Base* p);
Выводит реальный тип объекта, на который указывает p: "A", "B" или "C".
void identify(Base& p);
Выводит фактический тип объекта, на который указывает p: "A", "B" или "C". Использование указателя
внутри этой функции запрещено.
Включение заголовка typeinfo запрещено.
Напишите программу для проверки того, что все работает так, как ожидалось.
