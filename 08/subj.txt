C++ - Module 08
Templated containers, iterators, algorithms

Правила, специфические для данного модуля
Вы заметите, что в этом модуле упражнения могут быть решены 
БЕЗ стандартных контейнеров и БЕЗ стандартных алгоритмов.
Однако их использование как раз и является целью данного модуля. 
Вам разрешается использовать STL. Да, вы можете использовать 
контейнеры (вектор/лист/мап/и т.д.) и Алгоритмы 
(определенные в заголовке <algorithm>). Более того, 
вы должны использовать их как можно больше
насколько это возможно. Таким образом, постарайтесь 
применить их везде, где это уместно.
В противном случае вы получите очень плохую оценку, 
даже если ваш код работает так, как ожидалось. Пожалуйста,
не ленитесь. Вы можете определить свои шаблоны в заголовочных файлах, 
как обычно. Или, если хотите, вы можете
можете написать объявления шаблонов в заголовочных файлах и написать их реализацию
в файлах .tpp. В любом случае, заголовочные файлы являются обязательными, 
а файлы .tpp - необязательными.

Упражнение 00: Легкая находка

Первое легкое упражнение - это способ начать с правильной ноги.
Напишите шаблон функции easyfind, которая принимает тип T. 
Она принимает два параметра.
Первый из них имеет тип T, а второй - целое число.
Предполагая, что T является контейнером целых чисел, эта 
функция должна найти первое вхождение
второго параметра в первом параметре.
Если вхождение не найдено, вы можете либо выбросить исключение, 
либо вернуть значение ошибки
по вашему выбору. Если вам нужно немного вдохновения, проанализируйте, 
как ведут себя стандартные контейнеры.
Конечно, реализуйте и включите свои собственные тесты, чтобы убедиться, 
что все работает так, как ожидается.
Вам не обязательно работать с ассоциативными контейнерами.

Упражнение 01: Span

Разработайте класс Span, который может хранить максимум N целых чисел. 
N - это беззнаковая переменная int
и будет единственным параметром, передаваемым в конструктор.

Этот класс будет иметь функцию-член addNumber() для добавления одного числа
к диапазону. Она будет использоваться для его заполнения. 
Любая попытка добавить новый элемент, если
уже имеется N элементов, должна вызывать исключение.

Далее реализуйте две функции-члена: shortestSpan() и longestSpan().
Они, соответственно, определят самый короткий или самый длинный промежуток 
(или расстояние, по вашему желанию) между всеми хранящимися числами.
между всеми хранящимися числами и возвращать их. Если в памяти нет ни одного числа,
или только одно, пролет не может быть найден. Таким образом, выбросьте исключение.
Конечно, вы напишете свои собственные тесты, и они будут гораздо более 
тщательными, чем приведенные ниже.
Протестируйте свой Span как минимум на 10 000 числах. 
Больше будет еще лучше.

Запуск этого кода:

int main()
{
	Span sp = Span(5);
	sp.addNumber(6);
	sp.addNumber(3);
	sp.addNumber(17);
	sp.addNumber(9);
	sp.addNumber(11);
	std::cout << sp.shortestSpan() << std::endl;
	std::cout << sp.longestSpan() << std::endl;
	return 0;
}

Should output:

$> ./ex01
2
14
$>

И последнее, но не менее важное: было бы замечательно заполнять 
Span, используя диапазон итераторов.
Выполнение тысячи вызовов addNumber() так раздражает. Реализуйте 
функцию-член для добавления многих чисел в ваш Span за один вызов.

Если у вас нет идей, изучите контейнеры. Некоторые функции-члены
функции принимают диапазон итераторов, чтобы добавить последовательность
элементов в контейнер.

Упражнение 02: Мутировавшая мерзость

Теперь пора переходить к более серьезным вещам. Давайте 
разработаем нечто странное. Контейнер std::stack очень хорош.
К сожалению, это один из единственных контейнеров STL, 
который НЕ является итерируемым. Это очень плохо.
Но почему мы должны с этим мириться? Особенно, если мы можем 
взять на себя смелость испортить
оригинальный стек, чтобы создать недостающие функции.
Чтобы исправить эту несправедливость, нужно сделать контейнер 
std::stack итерабельным. Напишите класс MutantStack. 
Он будет реализован в терминах стека std::stack.
Он будет предлагать все свои функции-члены, плюс 
дополнительную возможность: итераторы.
Конечно, вы напишете и проведете собственные тесты, 
чтобы убедиться, что все работает так, как ожидается.

Find a test example below

int main()
{
	MutantStack<int> mstack;
	mstack.push(5);
	mstack.push(17);
	std::cout << mstack.top() << std::endl;
	mstack.pop();
	std::cout << mstack.size() << std::endl;
	mstack.push(3);
	mstack.push(5);
	mstack.push(737);
	//[...]
	mstack.push(0);
	MutantStack<int>::iterator it = mstack.begin();
	MutantStack<int>::iterator ite = mstack.end();
	++it;
	--it;
	while (it != ite)
	{
	std::cout << *it << std::endl;
	++it;
	}
	std::stack<int> s(mstack);
	return 0;
}

Если вы запустите его в первый раз с вашим MutantStack, 
а во второй раз замените
MutantStack, например, на std::list, то два результата 
должны быть одинаковыми. Конечно,
Конечно, при тестировании другого контейнера, обновите 
приведенный ниже код соответствующими
функции-члены (push() может стать push_back()).